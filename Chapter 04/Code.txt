** Define the "AWS_ACCESS_KEY" and "AWS_SECRET_KEY" variables with default values:
# vars.tf
# Input Variables https://www.terraform.io/language/values/variables

variable "aws_access_key" {
}
	variable "aws_secret_key" {
}

variable "apac_region" {
	default = "ap-south-1"
}
variable "cidr_blocks" {
	default = "0.0.0.0/0"
}
#Network Mask - 255.255.255.0 Addresses Available - 256
variable "vpc_cidr" {
	default = "10.0.1.0/24"
}

variable "public_cidr" {
	default = "10.0.1.0/28"
}
variable "private_cidr" {
	default = "10.0.1.16/28"
}
variable "instance_type" {
	default = "t2.micro"
}

#Providers are a logical abstraction of an upstream API. They help to understand API interactions and exposing provider resources such AWS, Google, Azure - https://registry.terraform.io/browse/providers.
provider "aws" {
	region = var.apac_region
}

** devVPC.tf
# Providers are a logical abstraction of an upstream API. They help to understand API interactions and exposing provider resources such AWS, Google, Azure
provider "aws" {
	region = var.apac_region
}
# Query all available Availability Zone; we will use specific availability zone using index - The Availability Zones data source provides access to the list of AWS Availability Zones which can be accessed by an AWS account specific to region configured in the provider.
data "aws_availability_zones" "available" {}

# Provides a VPC resource
resource "aws_vpc" "devVPC" {
	cidr_block = var.vpc_cidr
	enable_dns_hostnames = true
	enable_dns_support = true
	tags = {
		Name = "dev_terraform_vpc"
	}
}
# Public Subnet - Provides an VPC subnet resource
resource "aws_subnet" "public_subnet" {
	cidr_block = var.public_cidr
	vpc_id = aws_vpc.devVPC.id
	map_public_ip_on_launch = true
	availability_zone = data.aws_availability_zones.available.names[1]
	tags = {
		Name = "dev_terraform_vpc_public_subnet"
	}
}
# Private Subnet - Provides an VPC subnet resource
resource "aws_subnet" "private_subnet" {
	cidr_block = var.private_cidr
	vpc_id = aws_vpc.devVPC.id
	map_public_ip_on_launch = false
	availability_zone = data.aws_availability_zones.available.names[1]
	tags = {
		Name = "dev_terraform_vpc_private_subnet"
	}
}
#To access EC2 instance inside a Virtual Private Cloud (VPC) we need an Internet Gateway and a routing table connecting the subnet to the Internet Gateway
# Creating Internet Gateway
# Provides a resource to create a VPC Internet Gateway
resource "aws_internet_gateway" "igw" {
	vpc_id = aws_vpc.devVPC.id
	tags = {
		Name = "dev_terraform_vpc_igw"
	}
}
# Provides a resource to create a VPC routing table
resource "aws_route_table" "public_route" {
	vpc_id = aws_vpc.devVPC.id
	route {
		cidr_block = var.cidr_blocks
		gateway_id = aws_internet_gateway.igw.id
	}
	tags = {
		Name = "dev_terraform_vpc_public_route"
	}
}
# Provides a resource to create an association between a Public Route Table and a Public Subnet
resource "aws_route_table_association" "public_subnet_association" {
	route_table_id = aws_route_table.public_route.id
	subnet_id = aws_subnet.public_subnet.id
	depends_on = [aws_route_table.public_route, aws_subnet.public_subnet]
}

# Provides a security group resource - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/security_group
resource "aws_security_group" "sg_allow_ssh_http" {
	vpc_id = aws_vpc.devVPC.id
	name = "dev_terraform_vpc_allow_ssh_http"
	tags = {
		Name = "dev_terraform_sg_allow_ssh_http"
	}
}
# Ingress Security Port 22 (Inbound) - Provides a security group rule resource (https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/security_group_rule)
resource "aws_security_group_rule" "ssh_ingress_access" {
	from_port = 22
	protocol = "tcp"
	security_group_id = aws_security_group.sg_allow_ssh_http.id
	to_port = 22
	type = "ingress"
	cidr_blocks = [var.cidr_blocks]
}
# Ingress Security Port 80 (Inbound)
	resource "aws_security_group_rule" "http_ingress_access" {
	from_port = 80
	protocol = "tcp"
	security_group_id = aws_security_group.sg_allow_ssh_http.id
	to_port = 80
	type = "ingress"
	cidr_blocks = [var.cidr_blocks]
}
# Ingress Security Port 8080 (Inbound)
resource "aws_security_group_rule" "http8080_ingress_access" {
	from_port = 8080
	protocol = "tcp"
	security_group_id = aws_security_group.sg_allow_ssh_http.id
	to_port = 8080
	type = "ingress"
	cidr_blocks = [var.cidr_blocks]
}
# Egress Security (Outbound)
resource "aws_security_group_rule" "egress_access" {
	from_port = 0
	protocol = "-1"
	security_group_id = aws_security_group.sg_allow_ssh_http.id
	to_port = 0
	type = "egress"
	cidr_blocks = [var.cidr_blocks]
}

** The following is a script to create an AMI in Amazon EC2 using Packer. AMI will have Java and Jenkins installed in it. Create the jenkinsami-packer.json file:

{
"variables": {
	"aws_access_key": "",
	"aws_secret_key": ""
},
"builders": [
{
	"type": "amazon-ebs",
	"access_key": "{{user `aws_access_key`}}",
	"secret_key": "{{user `aws_secret_key`}}",
	"region": "ap-south-1",
	"source_ami": "ami-0c6615d1e95c98aca",
	"instance_type": "t2.micro",
	"ssh_username": "ec2-user",
	"ami_name": "packer-jenkins-ami-{{timestamp}}"
}
],
"provisioners": [
{
	"type": "shell",
	"inline": [
	"sudo yum update –y",
	"sudo yum remove java -y",
	"sudo yum install java-1.8.0-openjdk-devel -y",
	"sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo",
	"sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key",
	"sudo yum install jenkins -y"
]
}
]
}

Execute packer build -var "aws_access_key=XXXXXXXXXXXXXXXXXXXX" -var "aws_secret_key=XXXXXXXXXXXXXXXXXXXX" jenkinsami-packer.json.

#Get latest AMI ID based on Filter - Here AMI created using Packer
data "aws_ami" "packeramis" {
	owners = ["10xxxxxxxxxx"] #change the owner ID as per your account
	most_recent = true
	filter {
		name = "name"
		values = ["packer-jenkins*"]
	}
}

#Create an Instance using latest Packer AMI
resource "aws_instance" "jenkins-instance" {
	ami = data.aws_ami.packeramis.id
	instance_type = var.instance_type
	key_name = "terraform"
	vpc_security_group_ids = [aws_security_group.sg_allow_ssh_http.id]
	subnet_id = aws_subnet.public_subnet.id
	tags = {
		Name = "dev_terraform_jenkins_instance"
	}
}

The following is the Terraform script that creates security group for EFS. Note the name of security group that we will refer to in the upcoming script:

# Ingress Security Port 2049 (Inbound)
resource "aws_security_group" "sg_jenkins_efs" {
	name_prefix = "sg_jenkins_efs"
	vpc_id = aws_vpc.devVPC.id
	ingress {
		from_port = 2049
		to_port = 2049
		protocol = "tcp"
		cidr_blocks = [var.cidr_blocks]
	}
}

Create EC2 instance using Terraform and once instance is available, execute the following commands in EC2 instance:
#!/bin/bash
sudo yum update -y
sudo yum install nfs-utils
#Mount EFS Mount Access point
sudo mkdir /root/.jenkins
sudo mount -t nfs4 -o nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport fs-0d6103dd6806be283.efs.ap-south-1.amazonaws.com:/ /root/.jenkins

The following code will create EFS, access point, and mount target:
# Provides an Elastic File System (EFS) File System resource to store JENKINS_HOME
resource "aws_efs_file_system" "jenkins_home_efs" {

	creation_token = "jenkins_home_efs"
	tags = {
		Name = "dev_terraform_jenkins_home"
	}
}
# Provides an Elastic File System (EFS) mount target
resource "aws_efs_mount_target" "jenkins_mount_target" {
	file_system_id = aws_efs_file_system.jenkins_home_efs.id
	subnet_id = aws_subnet.public_subnet.id
	security_groups = [aws_security_group.sg_jenkins_efs.id]
}
# Provides an Elastic File System (EFS) access point
resource "aws_efs_access_point" "jenkins_access_point" {
	file_system_id = aws_efs_file_system.jenkins_home_efs.id
	root_directory {
		path = "/"
	}
}


Create a userdata.tpl file with the following content and change the file system ID in the userdata.tpl file to the new file system created by terraform script above:
#!/bin/bash
sudo yum update -y
sudo yum install nfs-utils
#Mount EFS Mount Access point
sudo mkdir /root/.jenkins
sudo mount -t nfs4 -o nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport fs-0d6103dd6806be283.efs.ap-south-1.amazonaws.com:/ /root/.jenkins

Add the template_file block in the main terraform file and provide its reference in instance configuration, as follows:
#The template_file data source usually loaded from an external file.
data "template_file" "init" {
	template = file("${path.module}/userdata.tpl")
}

#Create an Instance using latest Packer AMI and apply User Data - This allows instances to be created, updated, and deleted - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/instance
resource "aws_instance" "jenkins-instance" {
	ami = data.aws_ami.packeramis.id
	instance_type = var.instance_type
	key_name = "terraform"
	vpc_security_group_ids = [aws_security_group.sg_allow_ssh_http.id]
	subnet_id = aws_subnet.public_subnet.id
	user_data = data.template_file.init.rendered
	tags = {
		Name = "dev_terraform_jenkins_instance"
	}
}

Let’s create launch configuration using the aws_launch_configuration resource and autoscaling group using aws_autoscaling_group.
We will also define policies to scale resources up and down. Create autoscaling.tf and copy the following script into it:

resource "aws_launch_configuration" "nginx_launch_config" {
	image_id = data.aws_ami.packeramis.id
	instance_type = var.instance_type
	security_groups = [aws_security_group.sg_allow_ssh_http.id]
	user_data = data.template_file.init.rendered
	lifecycle {
		create_before_destroy = true
	}
}

resource "aws_autoscaling_group" "nginx_autoscaling_group" {
	launch_configuration = aws_launch_configuration.nginx_launch_config.id
	vpc_zone_identifier = [aws_subnet.public_subnet.id]
	health_check_type = "ELB"
	min_size = 2
	max_size = 5
	load_balancers = [aws_elb.nginx-elb.id]
	tag {
		key = "Name"
		value = "dev_terraform_nginx_instance_asg"
		propagate_at_launch = true
	}
}

resource "aws_autoscaling_policy" "nginx_cpu_policy_scaleup" {
	name = "nginx_cpu_policy_scaleup"
	autoscaling_group_name = aws_autoscaling_group.nginx_autoscaling_group.name
	adjustment_type = "ChangeInCapacity"
	scaling_adjustment = 1
	cooldown = "120"
}

resource "aws_autoscaling_policy" "nginx_cpu_policy_scaledown" {
	name = "nginx_cpu_policy_scaledown"
	autoscaling_group_name = aws_autoscaling_group.nginx_autoscaling_group.name
	adjustment_type = "ChangeInCapacity"
	scaling_adjustment = -1
	cooldown = "120"
}

Let’s create Elastic load balancer and configure listener as well as health check details. Create a file named elb.tf:
# Elastic Load Balancer resource, also known as a Classic Load Balancer - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/elb
resource "aws_elb" "nginx-elb" {
	name = "nginx-elb"
	subnets = [aws_subnet.public_subnet.id]
	security_groups = [aws_security_group.sg_allow_ssh_http.id]
	listener {
		instance_port = 80
		instance_protocol = "http"
		lb_port = 80
		lb_protocol = "http"
	}
	health_check {
		healthy_threshold = 2
		unhealthy_threshold = 2
		timeout = 2
		target = "HTTP:80/"
		interval = 30
	}
	tags = {
		Name = "nginx_elb"
	}
}
Add load_balancers = [aws_elb.nginx-elb.id] in the auto scaling group that we created earlier to link ELB and Auto scaling group:
resource "aws_autoscaling_group" "nginx_autoscaling_group" {
	launch_configuration = aws_launch_configuration.nginx_launch_config.id
	vpc_zone_identifier = [aws_subnet.public_subnet.id]
	health_check_type = "ELB"
	min_size = 2
	max_size = 5
	load_balancers = [aws_elb.nginx-elb.id]
	tag {
		key = "Name"
		value = "dev_terraform_nginx_instance_asg"
		propagate_at_launch = true
	}
}